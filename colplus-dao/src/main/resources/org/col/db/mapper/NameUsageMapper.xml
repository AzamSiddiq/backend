<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.col.db.mapper.NameUsageMapper">

    <resultMap id="issueResultMap" type="NameUsageWrapper" autoMapping="true">
        <result property="issues" column="issues" typeHandler="org.col.db.type2.IssueSetTypeHandler" />
    </resultMap>


    <resultMap id="taxonResultMap" type="NameUsageWrapper" autoMapping="true" extends="issueResultMap">
        <id column="id" />
        <association property="usage" javaType="Taxon" autoMapping="true">
            <id property="id" column="id" />
            <result property="lifezones" column="lifezones" typeHandler="org.col.db.type.LifezoneSetTypeHandler" />
            <association property="name" javaType="Name" resultMap="org.col.db.mapper.NameMapper.nameResultMap" columnPrefix="n_" />
        </association>
        <collection property="vernacularNames" ofType="VernacularName" autoMapping="true" notNullColumn="v_key">
            <id property="key" column="v_key"/>
        </collection>
    </resultMap>

    <resultMap id="taxonWithClassificationResultMap" type="NameUsageWrapper" autoMapping="true" extends="taxonResultMap">
        <result property="classificationIds" column="classificationIds" typeHandler="org.col.db.type.StringArrayTypeHandler"/>
        <result property="classificationNames" column="classificationNames" typeHandler="org.col.db.type.StringArrayTypeHandler"/>
        <result property="classificationRanks" column="classificationRanks" typeHandler="org.col.db.type.RankArrayTypeHandler"/>
    </resultMap>

    <resultMap id="taxonGetClassificationResultMap" type="NameUsageWrapper" autoMapping="true" extends="taxonResultMap">
        <collection property="classification" ofType="SimpleName" column="{id=id,datasetKey=dataset_key}" autoMapping="true" select="selectClassification"/>
    </resultMap>

    <resultMap id="synonymResultMap" type="NameUsageWrapper" autoMapping="true" extends="issueResultMap">
        <id column="s_id" />
        <id column="n_id" />
        <association property="usage" javaType="Synonym" resultMap="org.col.db.mapper.SynonymMapper.synonymResultMap" autoMapping="true">
            <id column="n_id" />
            <id column="a_id" />
        </association>
    </resultMap>

    <resultMap id="bareNameResultMap" type="NameUsageWrapper" autoMapping="true" extends="issueResultMap">
        <id column="n_id"/>
        <association property="usage" javaType="BareName">
            <id column="n_key" />
            <association property="name" javaType="Name" resultMap="org.col.db.mapper.NameMapper.nameResultMap" columnPrefix="n_" />
        </association>
    </resultMap>


    <sql id="taxonSelectFrom">
        vbn.issues || vbt.issues AS issues,
        <include refid="org.col.db.mapper.NameMapper.nameCols">
            <property name="alias" value="n"/>
            <property name="prefix" value="n_"/>
        </include>,
        <include refid="org.col.db.mapper.TaxonMapper.taxonCols">
            <property name="alias" value="t"/>
            <property name="prefix" value=""/>
        </include>,
        <if test="datasetKey != @org.col.api.vocab.Datasets@DRAFT_COL">
            ed.key AS decisionKey,
        </if>
        vn.key as v_key, vn.name, vn.latin, vn.language
    FROM <include refid="org.col.db.mapper.TaxonMapper.FROM"/>
        LEFT JOIN verbatim_${datasetKey} vbt ON vbt.key=t.verbatim_key
        LEFT JOIN verbatim_${datasetKey} vbn ON vbn.key=n.verbatim_key
        LEFT JOIN vernacular_name_${datasetKey} vn ON vn.taxon_id=t.id
        <if test="datasetKey != @org.col.api.vocab.Datasets@DRAFT_COL">
            LEFT JOIN decision ed ON ed.subject_id=t.id AND ed.dataset_key=#{datasetKey}
        </if>
    </sql>
    <!--  select all name usages of a dataset
        Using a optimal fetchsize to enable low memory footprint while keeping good performance using a resulthandler
    -->
    <select id="processDatasetTaxa" parameterType="map" resultMap="taxonWithClassificationResultMap" resultOrdered="true" fetchSize="10000" resultSetType="FORWARD_ONLY">
        WITH RECURSIVE tree AS(
            SELECT
                ARRAY[t.id]::text[] AS classificationIds,
                ARRAY[n.rank]::rank[] AS classificationRanks,
                ARRAY[n.scientific_name]::text[] AS classificationNames,
            <include refid="taxonSelectFrom" />
	        WHERE t.parent_id IS NULL
	        <if test="sectorKey != null">
	        	AND t.sector_key = #{sectorKey}
    	    </if>
	        
            UNION

            SELECT
                array_append(tree.classificationIds, t.id),
                array_append(tree.classificationRanks, n.rank),
                array_append(tree.classificationNames, n.scientific_name),
            <include refid="taxonSelectFrom" />
                JOIN tree ON (tree.id = t.parent_id)
		        <if test="sectorKey != null">
		        	WHERE t.sector_key = #{sectorKey}
	    	    </if>
	   )
	   SELECT * FROM tree
    </select>

    <select id="processDatasetSynonyms" parameterType="map" resultMap="synonymResultMap" resultOrdered="true" fetchSize="10000" resultSetType="FORWARD_ONLY">
        SELECT <include refid="org.col.db.mapper.SynonymMapper.SELECT"/>,
            vbn.issues || vb.issues AS issues
        FROM <include refid="org.col.db.mapper.SynonymMapper.FROM"/>
            LEFT JOIN verbatim_${datasetKey} vb  ON vb.key = s.verbatim_key
            LEFT JOIN verbatim_${datasetKey} vbn ON vbn.key= n.verbatim_key
	        <if test="sectorKey != null">
	        	WHERE a.sector_key = #{sectorKey}
    	    </if>
        ORDER BY s.taxon_id
    </select>

    <select id="processDatasetBareNames" parameterType="map" resultMap="bareNameResultMap" resultOrdered="true" fetchSize="10000" resultSetType="FORWARD_ONLY">
        SELECT v.issues,
        <include refid="org.col.db.mapper.NameMapper.nameCols">
            <property name="alias" value="n"/>
            <property name="prefix" value="n_"/>
        </include>
        FROM name_${datasetKey} n
            LEFT JOIN synonym_${datasetKey}  s ON n.id = s.name_id
            LEFT JOIN taxon_${datasetKey}    t ON n.id = t.name_id
            LEFT JOIN verbatim_${datasetKey} v ON v.key= n.verbatim_key
        WHERE t.id IS NULL AND s.taxon_id IS NULL
        <if test="sectorKey != null">
        	AND n.sector_key = #{sectorKey}
   	    </if>
    </select>

    <select id="get" parameterType="map" resultMap="taxonGetClassificationResultMap">
        SELECT
        <include refid="taxonSelectFrom" />
        WHERE t.id = #{id}
    </select>

    <select id="selectClassification" parameterType="map" resultType="SimpleName">
        WITH RECURSIVE cl AS (
            SELECT t.id, t.parent_id, n.scientific_name as name, n.authorship, n.rank
            FROM <include refid="org.col.db.mapper.TaxonMapper.FROM"/>
            WHERE t.id = #{id}

            UNION

            SELECT t.id, t.parent_id, n.scientific_name, n.authorship, n.rank
            FROM <include refid="org.col.db.mapper.TaxonMapper.FROM"/>, cl
            WHERE t.id = cl.parent_id
        )
        SELECT *
        FROM cl
        WHERE cl.id != #{id}
    </select>
</mapper>
