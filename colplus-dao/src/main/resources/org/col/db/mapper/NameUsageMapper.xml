<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.col.db.mapper.NameUsageMapper">


    <sql id="usageCols">
        ${alias}.id AS ${prefix}id,
        ${alias}.dataset_key AS ${prefix}dataset_key,
        ${alias}.sector_key AS ${prefix}sector_key,
        ${alias}.verbatim_key AS ${prefix}verbatim_key,
        ${alias}.status AS ${prefix}status,
        ${alias}.origin AS ${prefix}origin,
        ${alias}.parent_id AS ${prefix}parent_id,
        ${alias}.according_to AS ${prefix}according_to,
        ${alias}.remarks AS ${prefix}remarks,
        ${alias}.created AS ${prefix}created,
        ${alias}.created_by AS ${prefix}created_by,
        ${alias}.modified AS ${prefix}modified,
        ${alias}.modified_by AS ${prefix}modified_by
    </sql>

    <sql id="SELECT">
    </sql>

    <sql id="COLS">
        dataset_key,
        sector_key,
        verbatim_key,
        parent_id,
        name_id,
        status,
        is_synonym,
        origin,
        according_to,
        remarks,
        created_by,
        modified_by
    </sql>

    <sql id="PROPS">
        #{datasetKey},
        #{sectorKey},
        #{verbatimKey},
        #{parentId},
        #{name.id},
        #{status},
        #{status.synonym},
        #{origin},
        #{accordingTo},
        #{remarks},
        #{createdBy},
        #{modifiedBy}
    </sql>

    <sql id="FROM">
        name_usage_${datasetKey} u JOIN name_${datasetKey} n ON u.name_id=n.id
    </sql>

    <resultMap id="usageResultMap" type="NameUsageBase" autoMapping="true">
        <id property="id" column="id" />
        <discriminator column="is_synonym" javaType="boolean">
            <case value="false" resultType="Taxon"   resultMap="taxonResultMap"/>
            <case value="true"  resultType="Synonym" resultMap="synonymResultMap"/>
        </discriminator>
    </resultMap>

    <resultMap id="usageBaseResultMap" type="NameUsageBase" autoMapping="true">
        <id property="id" column="id" />
        <association property="name" javaType="Name" resultMap="org.col.db.mapper.NameMapper.nameResultMap" columnPrefix="n_" />
    </resultMap>
    <resultMap id="taxonResultMap" type="Taxon" autoMapping="true" extends="usageBaseResultMap">
        <result property="lifezones" column="lifezones" typeHandler="org.col.db.type.LifezoneSetTypeHandler" />
    </resultMap>
    <resultMap id="synonymResultMap" type="Synonym" autoMapping="true" extends="usageBaseResultMap">
        <association property="accepted" javaType="Taxon" resultMap="taxonResultMap" columnPrefix="a_" />
    </resultMap>

    <resultMap id="taxonCountResultMap" type="TaxonCountMap" autoMapping="false">
        <id property="id" column="id" />
        <result property="count" column="dataset_sectors" />
    </resultMap>


    <select id="count" resultType="integer">
        <include refid="org.col.db.mapper.Common.countFromFinishedDatasetImport">
            <property name="column" value="taxon_count"/>
        </include>
    </select>

    <select id="countChildren" resultType="integer">
        SELECT count(*) FROM name_usage_${datasetKey} where parent_id=#{id}
    </select>

    <select id="countRoot" resultType="integer">
        SELECT count(*)
        FROM name_usage_${datasetKey}
        WHERE dataset_key = #{datasetKey} AND parent_id IS NULL
    </select>

    <select id="list" resultMap="usageResultMap">
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        ORDER BY id
        <include refid="org.col.db.mapper.Common.limit" />
    </select>

    <select id="listRoot" resultMap="taxonResultMap">
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        WHERE u.parent_id IS NULL
        ORDER BY id
        <include refid="org.col.db.mapper.Common.limit" />
    </select>

    <select id="listByNameID" resultMap="usageResultMap">
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        WHERE t.name_id=#{nameId}
        ORDER BY id
    </select>

    <select id="listByName" resultMap="usageResultMap">
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        WHERE n.scientific_name=#{name}
        <if test="rank != null">
            AND n.rank=#{rank}::rank
        </if>
        ORDER BY id
    </select>

    <select id="listSynonyms" resultMap="synonymResultMap">
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        WHERE u.parent_id = #{taxonId}
        ORDER BY u.status, n.homotypic_name_id, n.scientific_name
    </select>
    
    <select id="children" resultMap="taxonResultMap">
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        WHERE u.parent_id = #{id}
        ORDER BY n.rank, n.scientific_name
        <include refid="org.col.db.mapper.Common.limit" />
    </select>

    <select id="classification" resultMap="taxonResultMap">
        WITH RECURSIVE x AS(
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        WHERE u.id = #{id}
        UNION
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />, x
        WHERE u.id = x.parent_id
        )
        SELECT *
        FROM x
        WHERE x.id != #{id}
    </select>

    <select id="getCounts" resultMap="taxonCountResultMap">
        SELECT id, dataset_sectors
        FROM name_usage_${datasetKey}
        WHERE id = #{id}
    </select>

    <select id="classificationCounts" resultMap="taxonCountResultMap">
        WITH RECURSIVE x AS(
        SELECT id, parent_id, dataset_sectors
        FROM name_usage_${datasetKey} t
        WHERE u.id = #{id}
        UNION
        SELECT u.id, t.parent_id, t.dataset_sectors
        FROM name_usage_${datasetKey} t, x
        WHERE u.id = x.parent_id
        )
        SELECT id, dataset_sectors
        FROM x
    </select>

    <select id="get" resultMap="usageResultMap" flushCache="true">
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        WHERE u.id = #{id}
    </select>

    <insert id="create" parameterType="NameUsageBase" useGeneratedKeys="false" keyProperty="id">
        INSERT INTO name_usage_${datasetKey}
        (id, <include refid="COLS" />, created, modified)
        VALUES (#{id}, <include refid="PROPS" />, now(), now())
    </insert>

    <update id="update" parameterType="NameUsageBase" keyProperty="id">
        UPDATE name_usage_${datasetKey}
        SET (<include refid="COLS" />, created, modified)
        = (<include refid="PROPS" />, now(), now())
        WHERE id = #{id}
    </update>

    <update id="updateParentId" parameterType="map">
        UPDATE name_usage_${datasetKey}
        SET (parent_id, modified, modified_by)
        = (#{newParentId}, now(), #{user.key})
        WHERE parent_id = #{parentId}
    </update>

    <delete id="delete" parameterType="map">
        DELETE FROM name_usage_${datasetKey} WHERE id = #{id}
    </delete>

    <select id="processTree" parameterType="map" resultMap="taxonResultMap" resultOrdered="true" fetchSize="10000" resultSetType="FORWARD_ONLY">
        WITH RECURSIVE x AS(
        SELECT <include refid="SELECT" />
        <if test="depthFirst">
            ,concat_ws('|', n.scientific_name, u.id) AS path
        </if>
        FROM <include refid="FROM" />
        WHERE
        <choose>
            <when test="startID != null">
                u.id = #{startID}
            </when>
            <otherwise>
                u.parent_id IS NULL
            </otherwise>
        </choose>

        UNION

        SELECT <include refid="SELECT" />
        <if test="depthFirst">
            ,concat_ws('|', x.path, n.scientific_name, u.id)  AS path
        </if>
        FROM <include refid="FROM" />
        JOIN x ON x.id = t.parent_id
        <where>
            <if test="exclusions != null and !exclusions.isEmpty()">
                u.id NOT IN
                <foreach item="id" collection="exclusions" open="(" separator="," close=")">#{id}</foreach>
            </if>
            <if test="sectorKey != null">
                AND t.sector_key = #{sectorKey}
            </if>
        </where>

        )
        SELECT * FROM x
        <if test="depthFirst">
            ORDER BY x.path
        </if>
    </select>

    <select id="foreignChildren" resultMap="taxonResultMap">
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        JOIN taxon_3 p ON p.id=t.parent_id
        WHERE p.sector_key=#{sectorKey}
        AND t.sector_key!=#{sectorKey}
    </select>

    <delete id="deleteBySector" parameterType="map">
        DELETE FROM name_usage_${datasetKey} WHERE sector_key = #{sectorKey}
    </delete>

    <update id="incDatasetSectorCount">
        WITH RECURSIVE x AS (
        SELECT u.id, t.parent_id
        FROM name_usage_${datasetKey} t
        WHERE u.id = #{id}
        UNION
        SELECT u.id, t.parent_id
        FROM name_usage_${datasetKey} t, x
        WHERE u.id = x.parent_id
        )

        UPDATE name_usage_${datasetKey}
        SET dataset_sectors = jsonb_set( coalesce(dataset_sectors, '{}'), '{"${dkey}"}', to_jsonb( coalesce( (dataset_sectors->'${dkey}')::int, 0) + ${delta} ), true)
        WHERE id IN (SELECT id FROM x)
    </update>

    <update id="updateDatasetSectorCount">
        UPDATE name_usage_${datasetKey}
        SET dataset_sectors = to_jsonb( #{count, typeHandler=org.col.db.type.FastutilIntIntHandler} )
        WHERE id = #{id}
    </update>

    <update id="resetDatasetSectorCount">
        UPDATE name_usage_${datasetKey} AS t
        SET dataset_sectors = NULL
        FROM name n
        WHERE n.id=t.name_id
        AND n.rank &lt; 'genus'
        AND NOT t.is_synonym
    </update>

</mapper>
