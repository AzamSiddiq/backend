<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.col.db.mapper.NameUsageMapper">


    <sql id="usageCols">
        ${alias}.id AS ${prefix}id,
        ${alias}.dataset_key AS ${prefix}dataset_key,
        ${alias}.sector_key AS ${prefix}sector_key,
        ${alias}.verbatim_key AS ${prefix}verbatim_key,
        ${alias}.status AS ${prefix}status,
        ${alias}.origin AS ${prefix}origin,
        ${alias}.parent_id AS ${prefix}parent_id,
        ${alias}.according_to AS ${prefix}according_to,
        ${alias}.remarks AS ${prefix}remarks,
        ${alias}.created AS ${prefix}created,
        ${alias}.created_by AS ${prefix}created_by,
        ${alias}.modified AS ${prefix}modified,
        ${alias}.modified_by AS ${prefix}modified_by
    </sql>

    <sql id="SELECT">
        u.is_synonym,
        <include refid="org.col.db.mapper.TaxonMapper.taxonCols">
            <property name="alias" value="u"/>
            <property name="prefix" value=""/>
        </include>,
        <include refid="org.col.db.mapper.NameMapper.nameCols">
            <property name="alias" value="n"/>
            <property name="prefix" value="n_"/>
        </include>,
        <include refid="org.col.db.mapper.TaxonMapper.taxonCols">
            <property name="alias" value="a"/>
            <property name="prefix" value="a_"/>
        </include>,
        <include refid="org.col.db.mapper.NameMapper.nameCols">
            <property name="alias" value="an"/>
            <property name="prefix" value="a_n_"/>
        </include>
    </sql>

    <sql id="COLS">
        dataset_key,
        sector_key,
        verbatim_key,
        parent_id,
        name_id,
        status,
        is_synonym,
        origin,
        according_to,
        remarks,
        created_by,
        modified_by
    </sql>

    <sql id="PROPS">
        #{datasetKey},
        #{sectorKey},
        #{verbatimKey},
        #{parentId},
        #{name.id},
        #{status},
        #{status.synonym},
        #{origin},
        #{accordingTo},
        #{remarks},
        #{createdBy},
        #{modifiedBy}
    </sql>

    <sql id="FROM">
        name_usage_${datasetKey} u
            JOIN name_${datasetKey} n ON u.name_id=n.id
            LEFT JOIN name_usage_${datasetKey} a ON u.parent_id=a.id AND u.is_synonym
            LEFT JOIN name_${datasetKey} an ON a.name_id=an.id
    </sql>

    <resultMap id="usageResultMap" type="NameUsageBase" autoMapping="true">
        <id property="id" column="id" />
        <discriminator column="is_synonym" javaType="boolean">
            <case value="false" resultType="Taxon"   resultMap="org.col.db.mapper.TaxonMapper.taxonResultMap"/>
            <case value="true"  resultType="Synonym" resultMap="org.col.db.mapper.SynonymMapper.synonymResultMap"/>
        </discriminator>
    </resultMap>

    <select id="count" resultType="integer">
        SELECT count(*) from name_usage_${datasetKey}
    </select>

    <select id="list" resultMap="usageResultMap">
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        ORDER BY u.id
        <include refid="org.col.db.mapper.Common.limit" />
    </select>

    <select id="listByNameID" resultMap="usageResultMap">
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        WHERE u.name_id=#{nameId}
        ORDER BY u.id
    </select>

    <select id="listByName" resultMap="usageResultMap">
        SELECT <include refid="SELECT" />
        FROM <include refid="FROM" />
        WHERE lower(n.scientific_name) = lower(#{name})
        <if test="rank != null">
            AND n.rank=#{rank}::rank
        </if>
        ORDER BY u.id
    </select>

    <update id="updateParentId" parameterType="map">
        UPDATE name_usage_${datasetKey}
        SET (parent_id, modified, modified_by)
        = (#{newParentId}, now(), #{userKey})
        WHERE parent_id = #{parentId}
    </update>

    <delete id="deleteBySector" parameterType="map">
        DELETE FROM name_usage_${datasetKey} WHERE sector_key = #{sectorKey}
    </delete>

    <select id="processTree" parameterType="map" resultMap="usageResultMap" resultOrdered="true" fetchSize="10000" resultSetType="FORWARD_ONLY">
        WITH RECURSIVE x AS(
        SELECT <include refid="SELECT" />
        <if test="depthFirst">
            ,concat_ws('|', n.scientific_name, u.id) AS path
        </if>
        FROM <include refid="FROM" />
        WHERE
        <choose>
            <when test="startID != null">
                u.id = #{startID}
            </when>
            <otherwise>
                u.parent_id IS NULL
            </otherwise>
        </choose>
        AND NOT u.is_synonym

        UNION

        SELECT <include refid="SELECT" />
        <if test="depthFirst">
            ,concat_ws('|', x.path, not u.is_synonym, n.scientific_name, u.id)  AS path
        </if>
        FROM <include refid="FROM" />
        JOIN x ON x.id = u.parent_id
        <where>
            <if test="!includeSynonyms">
                NOT u.is_synonym
            </if>
            <if test="exclusions != null and !exclusions.isEmpty()">
                AND u.id NOT IN
                <foreach item="id" collection="exclusions" open="(" separator="," close=")">#{id}</foreach>
            </if>
            <if test="sectorKey != null">
                AND u.sector_key = #{sectorKey}
            </if>
        </where>

        )
        SELECT * FROM x
        <if test="depthFirst">
            ORDER BY x.path
        </if>
    </select>

</mapper>
