<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.col.db.mapper.NameMapper">

  <sql id="SELECT">
    n.key,
    n.id,
    n.dataset_key,
    n.scientific_name,
    n.rank,
    n.uninomial,
    n.genus,
    n.infrageneric_epithet,
    n.specific_epithet,
    n.infraspecific_epithet,
    n.notho,
    n.basionym_authors,
    n.basionym_ex_authors,
    n.basionym_year,
    n.combination_authors,
    n.combination_ex_authors,
    n.combination_year,
    n.sanctioning_author,
    n.code,
    n.status,
    n.origin,
    n.type,
    n.fossil,
    n.basionym_key,
    n.remarks,
    n.issues
  </sql>

  <sql id="COLS">
    id,
    dataset_key,
    scientific_name,
    rank,
    uninomial,
    genus,
    infrageneric_epithet,
    specific_epithet,
    infraspecific_epithet,
    notho,
    basionym_authors,
    basionym_ex_authors,
    basionym_year,
    combination_authors,
    combination_ex_authors,
    combination_year,
    sanctioning_author,
    code,
    status,
    origin,
    type,
    fossil,
    basionym_key,
    remarks,
    issues
  </sql>

  <sql id="PROPS">
    #{id},
    #{datasetKey},
    #{scientificName},
    #{rank}::rank,
    #{uninomial},
    #{genus},
    #{infragenericEpithet},
    #{specificEpithet},
    #{infraspecificEpithet},
    #{notho},
    #{basionymAuthorship.authors, typeHandler=org.col.db.type.StringArrayTypeHandler},
    #{basionymAuthorship.exAuthors, typeHandler=org.col.db.type.StringArrayTypeHandler},
    #{basionymAuthorship.year},
    #{authorship.authors, typeHandler=org.col.db.type.StringArrayTypeHandler},
    #{authorship.exAuthors, typeHandler=org.col.db.type.StringArrayTypeHandler},
    #{authorship.year},
    #{sanctioningAuthor},
    #{code},
    #{status},
    #{origin},
    #{type},
    #{fossil},
    #{basionymKey},
    #{remarks},
    #{issues, typeHandler=org.col.db.type.HstoreIssueHandler}::hstore
  </sql>

  <sql id="FROM">
    name n LEFT JOIN name bn ON n.basionym_key=bn.key
  </sql>

  <!-- A mapping to Name, mostly auto mapped -->
  <resultMap id="nameResultMap" type="Name" autoMapping="true">
    <id property="key" column="key" />
    <result property="id" column="id" />
    <result property="issues" column="issues" typeHandler="org.col.db.type.HstoreIssueHandler" />
    <association property="authorship" javaType="Authorship">
      <result property="authors" column="combination_authors" typeHandler="org.col.db.type.StringArrayTypeHandler" />
      <result property="exAuthors" column="combination_ex_authors" typeHandler="org.col.db.type.StringArrayTypeHandler" />
      <result property="year" column="combination_year" />
    </association>
    <association property="basionymAuthorship" javaType="Authorship">
      <result property="authors" column="basionym_authors" typeHandler="org.col.db.type.StringArrayTypeHandler" />
      <result property="exAuthors" column="basionym_ex_authors" typeHandler="org.col.db.type.StringArrayTypeHandler" />
      <result property="year" column="basionym_year" />
    </association>
  </resultMap>



  <select id="lookupKey" resultType="Integer">
    SELECT key
    FROM name
    WHERE dataset_key = #{datasetKey} AND id = #{id}
  </select>

  <select id="count" parameterType="map" resultType="Integer">
    SELECT count(*)
    FROM name
    WHERE dataset_key = #{datasetKey}
  </select>

  <select id="list" parameterType="map" resultMap="nameResultMap">
    SELECT
    <include refid="SELECT" />
    FROM
    <include refid="FROM" />
    WHERE n.dataset_key = #{datasetKey}
    ORDER BY key
    <include refid="org.col.db.mapper.Common.limit" />
  </select>
  

  <select id="countSearchResults" parameterType="map" resultType="Integer">
    SELECT COUNT(*)
    FROM
        (
          SELECT <include refid="SELECT" />,
              setweight(to_tsvector(coalesce(n.genus,'')), 'A') ||
              setweight(to_tsvector(coalesce(n.infrageneric_epithet,'')), 'A') ||
              setweight(to_tsvector(coalesce(n.specific_epithet,'')), 'A') ||
              setweight(to_tsvector(coalesce(n.infraspecific_epithet,'')), 'A') ||
              setweight(to_tsvector(coalesce(n.scientific_name,'')), 'C') as document
          FROM name n  
        ) AS n
    WHERE n.document @@ plainto_tsquery(#{q})
  </select>

  <select id="search" parameterType="map" resultMap="nameResultMap">
    SELECT <include refid="SELECT" />
    FROM
        (
          SELECT <include refid="SELECT" />,
              setweight(to_tsvector(coalesce(n.genus,'')), 'A') ||
              setweight(to_tsvector(coalesce(n.infrageneric_epithet,'')), 'A') ||
              setweight(to_tsvector(coalesce(n.specific_epithet,'')), 'A') ||
              setweight(to_tsvector(coalesce(n.infraspecific_epithet,'')), 'A') ||
              setweight(to_tsvector(coalesce(n.scientific_name,'')), 'C') as document
          FROM name n  
        ) AS n
    WHERE n.document @@ plainto_tsquery(#{q})
    ORDER BY ts_rank(n.document, plainto_tsquery(#{q})) DESC
    <include refid="org.col.db.mapper.Common.limit"/>
  </select>

  <select id="get" resultMap="nameResultMap">
    SELECT
    <include refid="SELECT" />
    FROM
    <include refid="FROM" />
    WHERE n.key = #{key}
  </select>

  <insert id="create" parameterType="Name" useGeneratedKeys="true" keyProperty="key">
    INSERT INTO name (
    <include refid="COLS" />
    )
    VALUES (
    <include refid="PROPS" />
    )
  </insert>

  <select id="basionymGroup" resultMap="nameResultMap">
    SELECT
    <include refid="SELECT" />
    FROM name ns
    JOIN name n ON
    <!-- ns was the basionym of other combinations -->
    n.basionym_key=ns.key OR n.key = ns.key
    <!-- ns was a combination with a basionym -->
    OR n.key=ns.basionym_key OR n.basionym_key=ns.basionym_key
    LEFT JOIN name bn ON n.basionym_key=bn.key
    WHERE ns.key=#{key}
  </select>

  <insert id="addSynonym" parameterType="map">
    INSERT INTO synonyms (dataset_key, taxon_key, name_key)
    VALUES (#{datasetKey}, #{key}, #{nameKey})
  </insert>

  <select id="synonyms" resultMap="nameResultMap">
    SELECT
    <include refid="SELECT" />
    FROM
    <include refid="FROM" />
    JOIN synonyms s ON s.name_key=n.key
    WHERE s.taxon_key = #{key}
    ORDER BY COALESCE(n.basionym_key, n.key)
  </select>
</mapper>
