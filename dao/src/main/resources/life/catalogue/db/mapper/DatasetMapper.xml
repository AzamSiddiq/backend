<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="life.catalogue.db.mapper.DatasetMapper">

  <sql id="SELECT">
    <include refid="life.catalogue.db.mapper.DatasetArchiveMapper.SELECT"/>,
    d.deleted,
    d.gbif_key,
    d.gbif_publisher_key,
    d.private,
    <include refid="size"/> AS size
  </sql>

  <sql id="size">coalesce(uc.counter, (coalesce(di.taxon_count,0) + coalesce(di.synonym_count,0) + coalesce(di.bare_name_count,0)))</sql>

  <sql id="COLS">
    <include refid="life.catalogue.db.mapper.DatasetArchiveMapper.COLS"/>,
    deleted,
    gbif_key,
    gbif_publisher_key,
    private
  </sql>


  <sql id="PROPS">
    <include refid="life.catalogue.db.mapper.DatasetArchiveMapper.PROPS"/>,
    #{deleted},
    #{gbifKey},
    #{gbifPublisherKey},
    #{privat}
  </sql>

  <sql id="FROM">
    dataset d
      LEFT JOIN dataset_import di ON di.attempt=d.attempt AND di.dataset_key=coalesce(d.source_key,d.key)
      LEFT JOIN usage_count uc ON uc.dataset_key=d.key
  </sql>

  <sql id="FROM_PROJ">
    <if test="userKey != null">
      LEFT JOIN dataset proj ON d.source_key=proj.key AND d.origin = 'RELEASED'::DATASETORIGIN
    </if>
  </sql>

  <sql id="PRIVATE">
    <!-- magic number for admins -->
    <if test="userKey != -42">
      AND (NOT ${alias}.private <if test="userKey != null">
        OR COALESCE(${projAlias}.acl_editor, ${alias}.acl_editor) @> ARRAY[#{userKey}::int]
        OR COALESCE(${projAlias}.acl_reviewer, ${alias}.acl_reviewer) @> ARRAY[#{userKey}::int]</if>
      )
    </if>
  </sql>

  <sql id="SEARCH_WHERE">
    d.deleted IS NULL
    <include refid="PRIVATE">
      <property name="alias" value="d"/>
      <property name="projAlias" value="proj"/>
    </include>
    <if test="req != null">
      <if test="req.q != null">
        <!-- we use dollar quoted strings with a token ($Grtz5$) to avoid escaping quotes -->
        AND (
          f_unaccent(d.title) ILIKE f_unaccent($Grtz5$%${req.q}%$Grtz5$)
          OR f_unaccent(d.alias) ILIKE f_unaccent($Grtz5$%${req.q}%$Grtz5$)
          OR d.doc @@ plainto_tsquery('simple2', $Grtz5$%${req.q}%$Grtz5$)
        )
      </if>
      <if test="req.privat != null">
        AND d.private = #{req.privat}
      </if>
      <if test="req.code != null">
        AND d.settings @> jsonb_build_object('NOMENCLATURAL_CODE', #{req.code})
      </if>
      <if test="req.type != null and !req.type.isEmpty()">
        AND d.type IN <foreach item="o" collection="req.type" open="(" separator="," close=")">#{o}::DATASETTYPE</foreach>
      </if>
      <if test="req.origin != null and !req.origin.isEmpty()">
        AND d.origin IN <foreach item="o" collection="req.origin" open="(" separator="," close=")">#{o}::DATASETORIGIN</foreach>
      </if>
      <if test="req.contributesTo != null">
        AND exists(
          SELECT 1 FROM sector s JOIN dataset pr ON pr.key=s.dataset_key
          WHERE s.dataset_key=#{req.contributesTo} AND s.subject_dataset_key=d.key
          <include refid="PRIVATE">
            <property name="alias" value="pr"/>
            <property name="projAlias" value="pr"/>
          </include>
        )
      </if>
      <if test="req.hasSourceDataset != null">
        AND exists(
          SELECT 1 FROM sector s JOIN dataset pr ON pr.key=s.dataset_key
          WHERE subject_dataset_key=#{req.hasSourceDataset} AND s.dataset_key=d.key
        )
      </if>
      <if test="req.releasedFrom != null">
        AND d.source_key=#{req.releasedFrom}
        AND d.origin = 'RELEASED'::DATASETORIGIN
      </if>
      <if test="req.license != null and !req.license.isEmpty()">
        AND d.license IN <foreach item="o" collection="req.license" open="(" separator="," close=")">#{o}::LICENSE</foreach>
      </if>
      <if test="req.editor != null">
        AND d.acl_editor @> ARRAY[#{req.editor}::int]
      </if>
      <if test="req.reviewer != null">
        AND d.acl_reviewer @> ARRAY[#{req.reviewer}::int]
      </if>
      <if test="req.modifiedBy != null">
        AND d.modified_by = #{req.modifiedBy}
      </if>
      <if test="req.modified != null">
        AND di.finished > #{req.modified}
      </if>
      <if test="req.created != null">
        AND d.created > #{req.created}
      </if>
      <if test="req.issued != null">
        AND d.issued > #{req.issued}
      </if>
      <if test="req.minSize != null">
        AND <include refid="size"/> >= #{req.minSize}
      </if>
    </if>
  </sql>

  <resultMap id="datasetResultMap" type="Dataset" autoMapping="true">
    <id property="key" column="key"/>
    <result property="privat" column="private"/>
    <result property="contact" column="contact" typeHandler="life.catalogue.db.type.AgentTypeHandler"/>
    <result property="creator" column="creator" typeHandler="life.catalogue.db.type.AgentArrayTypeHandler"/>
    <result property="editor" column="editor" typeHandler="life.catalogue.db.type.AgentArrayTypeHandler"/>
    <result property="publisher" column="publisher" typeHandler="life.catalogue.db.type.AgentTypeHandler"/>
    <result property="contributor" column="contributor" typeHandler="life.catalogue.db.type.AgentArrayTypeHandler"/>
    <result property="identifier" column="identifier" typeHandler="life.catalogue.db.type2.HstoreMapTypeHandler"/>
    <collection property="source" ofType="Citation" column="{datasetKey=key}" select="life.catalogue.db.mapper.CitationMapper.list" />
  </resultMap>

  <resultMap id="settingsResultMap" type="DatasetSettings" autoMapping="false">
    <id column="key"/>
    <result property="settings" column="settings" typeHandler="life.catalogue.db.type2.SettingsTypeHandler"/>
  </resultMap>



  <select id="listAgents" resultMap="datasetResultMap">
    SELECT key, contact, creator, editor, publisher, contributor FROM dataset
  </select>

  <update id="updateAgents" parameterType="Dataset">
    UPDATE dataset SET (
    contact,
    creator,
    editor,
    publisher,
    contributor
    ) = (
    #{contact, typeHandler=life.catalogue.db.type.AgentTypeHandler},
    #{creator, typeHandler=life.catalogue.db.type.AgentArrayTypeHandler},
    #{editor, typeHandler=life.catalogue.db.type.AgentArrayTypeHandler},
    #{publisher, typeHandler=life.catalogue.db.type.AgentTypeHandler},
    #{contributor, typeHandler=life.catalogue.db.type.AgentArrayTypeHandler}
    )
    WHERE key = #{key}
  </update>



  <select id="keys" resultType="integer">
    SELECT key
    FROM dataset
    WHERE deleted IS NULL
    <if test="origin != null and origin.length > 0">
      AND origin IN <foreach item="o" collection="origin" open="(" separator="," close=")">#{o}::DATASETORIGIN</foreach>
    </if>
    ORDER BY key
  </select>

  <select id="process" parameterType="map" resultMap="datasetResultMap" resultOrdered="true" fetchSize="100" resultSetType="FORWARD_ONLY">
    SELECT <include refid="SELECT"/>
    FROM <include refid="FROM"/>
    WHERE deleted IS NULL
    <if test="filter != null">AND ${filter}</if>
  </select>

  <select id="count" resultType="integer">
    SELECT COUNT(*)
    FROM <include refid="FROM"/> <include refid="FROM_PROJ"/>
    WHERE <include refid="SEARCH_WHERE"/>
  </select>

  <select id="search" resultMap="datasetResultMap">
    SELECT <include refid="SELECT"/>
    FROM <include refid="FROM"/> <include refid="FROM_PROJ"/>
    WHERE <include refid="SEARCH_WHERE"/>
    ORDER BY
    <bind name="rev" value="false"/>
    <choose>
      <when test="req == null || req.sortBy == null">
        key
      </when>
      <otherwise>
        <bind name="rev" value="req.reverse"/>
        <bind name="sortBy" value="req.sortBy.name()"/>
        <choose>
          <when test="sortBy == 'RELEVANCE'">
            ts_rank_cd(d.doc, plainto_tsquery('simple2', #{req.q}))
            <bind name="rev" value="!req.reverse"/>
          </when>
          <when test="sortBy == 'SIZE' || sortBy == 'CREATED' || sortBy == 'MODIFIED'">
            ${req.sortBy.name().toLowerCase()}
            <bind name="rev" value="!req.reverse"/>
          </when>
          <when test="sortBy == 'AUTHORS'">
            lower((d.editor[1]).family),
            lower((d.creator[1]).family)
          </when>
          <when test="sortBy == 'ALIAS'">
            lower(d.alias)
          </when>
          <when test="sortBy == 'TITLE'">
            lower(d.title)
          </when>
          <otherwise>
            ${req.sortBy.name().toLowerCase()}
          </otherwise>
        </choose>
      </otherwise>
    </choose>
    <choose>
      <when test="rev">DESC NULLs LAST</when>
      <otherwise>ASC NULLs FIRST</otherwise>
    </choose>
    <include refid="life.catalogue.db.Common.limit"/>
  </select>

  <select id="list" resultMap="datasetResultMap">
    SELECT <include refid="SELECT"/>
    FROM <include refid="FROM"/>
    WHERE deleted IS NULL AND NOT private
    ORDER BY key
    <include refid="life.catalogue.db.Common.limit"/>
  </select>

  <select id="listNeverImported" resultMap="datasetResultMap">
    SELECT <include refid="SELECT"/>
    FROM dataset d
      LEFT JOIN dataset_import di ON di.dataset_key=d.key
      LEFT JOIN usage_count uc ON uc.dataset_key=d.key
    WHERE d.deleted IS NULL
      AND d.origin = 'EXTERNAL'
      AND coalesce((d.settings ->> 'import frequency')::int, 0) >= 0
      AND di.attempt IS NULL
    ORDER BY d.key ASC
    LIMIT #{limit}
  </select>

  <select id="listToBeImported" resultMap="datasetResultMap">
    SELECT *
    FROM (
      SELECT DISTINCT ON (d.key) di.state, di.finished,
      <include refid="SELECT"/>, (settings ->> 'import frequency')::int AS frequency
      FROM dataset d
        LEFT JOIN dataset_import di ON di.dataset_key=d.key
        LEFT JOIN usage_count uc ON uc.dataset_key=d.key
      WHERE d.deleted IS NULL
        AND d.origin = 'EXTERNAL'
        AND di.finished IS NOT NULL
        AND coalesce((d.settings ->> 'import frequency')::int, 0) > 0
      ORDER BY d.key, di.attempt DESC
    ) AS latest
    WHERE state != 'WAITING'::importstate AND (finished + frequency * interval '1 day') &lt; now()
    ORDER BY finished ASC
    LIMIT #{limit}
  </select>

  <select id="exists" resultType="boolean">
    SELECT EXISTS (
      SELECT 1 FROM dataset WHERE key = #{key} AND deleted IS NULL
    )
  </select>

  <select id="isPrivate" resultType="boolean">
    SELECT EXISTS (
      SELECT 1 FROM dataset WHERE key = #{key}
    ) AND (
      SELECT private FROM dataset WHERE key = #{key}
    )
  </select>

  <select id="latestRelease" resultType="integer">
    SELECT key FROM dataset
    WHERE source_key = #{key} AND deleted IS NULL <if test="public">AND NOT private</if>
    ORDER BY created DESC
    LIMIT 1
  </select>

  <select id="releaseAttempt" resultType="integer">
    SELECT key FROM dataset
    WHERE source_key = #{key} AND deleted IS NULL AND attempt = #{attempt}
    LIMIT 1
  </select>

  <select id="get" resultMap="datasetResultMap">
    SELECT <include refid="SELECT"/>
    FROM <include refid="FROM"/>
    WHERE key = #{key}
  </select>

  <select id="getByGBIF" resultMap="datasetResultMap">
    SELECT <include refid="SELECT"/>
    FROM <include refid="FROM"/>
    WHERE gbif_key = #{key}
  </select>

  <!--  makes sure to add creator to editors if its not a bot with key<100 -->
  <insert id="create" parameterType="Dataset" useGeneratedKeys="true" keyProperty="key">
    INSERT INTO dataset (<include refid="COLS"/>, source_key, origin, created, modified, acl_editor)
    VALUES (<include refid="PROPS"/>, #{sourceKey}, #{origin}::DATASETORIGIN, now(), now(),
      <if test="sourceKey != null">NULL</if>
      <if test="sourceKey == null">
        <if test="createdBy &lt; 100">NULL</if>
        <if test="createdBy &gt;= 100">array[#{createdBy}::int]</if>
      </if>
    )
  </insert>

  <!--  makes sure to add creator to editors -->
  <insert id="createWithKey" parameterType="Dataset" useGeneratedKeys="false">
    INSERT INTO dataset (key,<include refid="COLS"/>, source_key, origin, acl_editor, created, modified)
    VALUES (#{key},<include refid="PROPS"/>, #{sourceKey}, #{origin}::DATASETORIGIN, array[#{createdBy}::int], now(), now())
  </insert>

  <select id="getSettings" resultMap="settingsResultMap">
    SELECT key, settings
    FROM dataset
    WHERE key = #{key}
  </select>

  <update id="updateSettings" parameterType="map">
    UPDATE dataset SET (settings, modified_by, modified) =
      ( #{settings, typeHandler=life.catalogue.db.type2.SettingsTypeHandler}::JSONB, #{userKey}, now() )
    WHERE key = #{key}
  </update>


  <select id="getReviewer" resultType="it.unimi.dsi.fastutil.ints.IntSet">
    SELECT acl_reviewer FROM dataset WHERE key = #{key}
  </select>

  <update id="updateReviewer" parameterType="map">
    UPDATE dataset  SET (acl_reviewer, modified_by, modified) =
    ( #{reviewer, typeHandler=life.catalogue.db.type.IntSetTypeHandler}, #{userKey}, now() )
    WHERE key = #{key}
  </update>

  <update id="addReviewer" parameterType="map">
    UPDATE dataset SET (acl_reviewer, modified_by, modified) =
    ( acl_reviewer || #{reviewer}, #{userKey}, now() )
    WHERE key = #{key}
  </update>

  <update id="removeReviewer" parameterType="map">
    UPDATE dataset  SET (acl_reviewer, modified_by, modified) =
    ( array_remove(acl_reviewer, #{reviewer}), #{userKey}, now() )
    WHERE key = #{key}
  </update>

  <update id="removeReviewerEverywhere" parameterType="map">
    UPDATE dataset  SET (acl_reviewer, modified_by, modified) =
    ( array_remove(acl_reviewer, #{reviewer}), #{userKey}, now() )
    WHERE acl_reviewer @> ARRAY[#{reviewer}::int]
  </update>


  <select id="getEditors" resultType="it.unimi.dsi.fastutil.ints.IntSet">
    SELECT acl_editor FROM dataset WHERE key = #{key}
  </select>

  <update id="updateEditors" parameterType="map">
    UPDATE dataset  SET (acl_editor, modified_by, modified) =
      ( #{editor, typeHandler=life.catalogue.db.type.IntSetTypeHandler}, #{userKey}, now() )
    WHERE key = #{key}
  </update>

  <update id="addEditor" parameterType="map">
    UPDATE dataset SET (acl_editor, modified_by, modified) =
      ( acl_editor || #{editor}, #{userKey}, now() )
    WHERE key = #{key}
  </update>

  <update id="removeEditor" parameterType="map">
    UPDATE dataset  SET (acl_editor, modified_by, modified) =
      ( array_remove(acl_editor, #{editor}), #{userKey}, now() )
    WHERE key = #{key}
  </update>

  <update id="removeEditorEverywhere" parameterType="map">
    UPDATE dataset  SET (acl_editor, modified_by, modified) =
    ( array_remove(acl_editor, #{editor}), #{userKey}, now() )
    WHERE acl_editor @> ARRAY[#{editor}::int]
  </update>


  <update id="update" parameterType="Dataset">
    UPDATE dataset SET (<include refid="COLS"/>, modified) = (<include refid="PROPS"/>, now())
    WHERE key = #{key}
  </update>

  <select id="lastImportAttempt" resultType="Integer">
    SELECT attempt
    FROM dataset
    WHERE key=#{key}
  </select>

  <update id="updateLastImport" parameterType="integer">
    UPDATE dataset
    SET attempt = #{attempt}
    WHERE key = #{key}
  </update>

  <update id="delete" parameterType="map">
    UPDATE dataset SET deleted = now(), attempt=null, alias=null, gbif_key=null
    WHERE key = #{key}
  </update>

  <delete id="deletePhysically" parameterType="map">
    DELETE FROM dataset WHERE key = #{key}
  </delete>

</mapper>
